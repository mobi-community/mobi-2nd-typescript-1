# Pair-3 (Rin - Kimi - Daniel)

## 📆 타임라인

| 날짜 | 내용                                |
| ---- | ----------------------------------- |
| 1/11 | 시간 정하기, TASK 1완료, TASK2 진행 |
| 1/12 | TASK2 완료 TASK3 완료               |
| 1/13 | TASK4 완료, TASK5 진행              |
| 1/14 | TASK5 진행                          |
| 1/15 | TASK5 완료                          |
| 1/16 | READ.ME 정리 및 복습, 개인 공부     |
| 1/17 | 복습 및 개인 공부                   |

## 내용

---

### 📝 task1

###### 300자 요약

Typescript란 Javascript의 슈퍼셋으로 Javascript를 사용할 수 있는 환경이면 어디든 사용이 가능한 언어이다. </br>
동적 타입 언어인 JS에서 일어날 수 있는 타입 관련 에러를 사전에 타입을 지정하거나 자체적으로 </br>
추론함으로서 타입 에러를 사전에 예방하는 역할을 한다.
</br>
Typescript는 javascript와 달리 타입 에러를 런타임이 아닌 컴파일시에 검출한다. </br>
또한 자동 완성 기능을 지원하기 때문에 개발의 생산성을 높여서 쉽고 직관적인 코드 작성이 가능하며, </br>
타입 정보를 통해 코드를 이해하고 해석할 수 있어 간단한 문서화 만으로 다른 사람과의 협업이 가능하다.

---

### 📝 task2

#### 1. basic type

- number : 숫자 타입
- string : 문자열 타입
- boolean : 참/거짓
- any : 모든 타입을 의미.
- object : 객체와 배열 타입을 의미.
- array : 배열을 의미.
- unknown : 어떤 타입인지 알 수 없음을 의미.
- union : OR연산자 형태로 여러 타입 중 하나를 의미.
- conditional : 삼항 연산자 형태로 조건에 따라 타입을 선택.
- intersection : && 연산자 형태로 두 개 이상의 타입을 결합.
- type alias : 타입에 이름을 부여하여 재사용성을 높임.
- interface : 객체의 구조를 정의하여 타입을 지정.

2. utility type
   - enum: 열거형, 상수 집합 정의. 같은 개념의 집합을 묶는데 사용하며, 객체 메서드 사용 가능.
   - as const: 리터럴 유형 추론, 불변 객체 생성. 모든 속성을 readonly로 바꿔 수정 불가능하게 만듦.
   - record<keys 타입, value 타입> : key, value의 타입을 각각 지정해서 만드는 타입
   - partial : 객체의 모든 속성을 선택적(optional : ?)으로 만드는 유틸리티 타입
   - omit<T, T에 있는 속성 키> : 첫번째 제네릭 T에서 특정 속성을 제거하여 새 타입을 생성하는 데 사용
   - pick<T, T에 있는 속성 키> : 첫번째 제네릭 T에서 특정 속성을 선택하여 새 타입을 생성하는 데 사용
   - extract<T,U> : 첫 번째 제네릭 타입 T가 두 번째 제네릭 타입 U의 조건을 충족하는 경우에는 T를 반환하고, 그렇지 않으면 never를 반환한다.
   - returnType : 해당 함수의 반환값 타입.
   - optional : 해당 타입에 사용 유무를 선택적으로 만듬.
   - satisfies : 안전한 타입 표명을 위해 사용. satisfies 뒤에 연결된 타입을 만족하는지를 간단하고 유연하게 검사함.
   - generic : 타입을 나중에 지정할 수 있도록 하여 코드 재사용성을 높이는 타입. 변신 로보트처럼 <>안에 넣은 타입으로 내부
     코드를 해당 타입에 맞춰 자유롭게 사용할 수 있음.

---

### 📝 task3

1. 개발 문서화 : TS의 타입 정보를 통해 변수의 구조, 함수의 Props, 반환값 정보등 많은 정보를

   유추하고 해석할 수 있다. 기존에 Js Docs를 통해 기술해야 할 정보의 양이 줄어들었다.

2. 생산성 (자동완성) : 작성된 타입 정보를 기반으로 IDE가 코드 작성 중에 미리 보기 및 자동 완성을 지원한다.

3. 안정적인 개발 환경: tsconfig.json 의 내용을 기반으로 컴파일시 타입 체커를 통해 타입 관련 에러를 잡아낸다.

   그래서 원래 JS라면 런타임시에 일어났을 타입 에러가 사전 예방 됨으로써,

   좀더 안정적인 개발 환경을 만들어준다.

**타입스크립트의 단점**

TS는 타입을 변수를 사용할 때마다 지정해줘야 하는 번거로움이 있고, 이런 타입들 때문에 코드의 가독성이 떨어지기도 한다.

또한 라이브러리를 설치할 때 타입 정보가 있는 모듈을 추가적으로 설치해야 한다.(라이브러리에 기본 내장되어 있는 경우가 많지만, 아닌 경우도 있으므로..)

JS 기반이지만, any없이 타입스크립트를 완벽하게 쓰는 것은 쉽지 않다. 대충 쓰면 안 쓰느니만 못한다는 이야기가 있을 정도로,

TS를 잘 쓰기 까지 러닝커브가 있다는 점을 감안해야 한다.

---

### 📝 task4

1. React.FC

   - 18버전 이상에서는 children은 더 이상 props 타입에 암묵적으로 포함되지 않으며 명시적으로 선언해야 한다.
   - React.FC를 사용할 때 컴포넌트가 ReactElement가 아닌 ReactNode를 반환하도록 변경되었다.

2. ReactNode

   - 리액트가 랜더링할 수 있는 모든 것을 허용하는 타입리액트가 랜더링할 수 있는 모든 것을 허용하는 타입.

3. ReactElement

   - 원시 타입을 제외한 jsx만을 허용하는 타입.

4. PropsWithChildren

   - react컴포넌트의 프로퍼티(props) 중에서 children이라는 프로퍼티를 포함하는 경우에 사용되는 generic타입
   - 컴포넌트의 자식 요소에 대한 타입 정보를 명시적으로 다룰 수 있음.

5. PropsWithRef

   - react에 ref를 사용하기 위한 타입
   - forwardRef를 사용해 ref의 타입을 지정하는 것이 더욱 보편적임.

6. RefObject

   - ref의 타입을 안전하게 다루기 위한 인터페이스.
   - 지정 타입과 초기값에 따라 ref사용 목적이 바뀐다.

7. SetStateAction

   - useState의 set함수를 props로 받을 때 지정해주는 타입.
   - set함수의 반환 원리를 담고있다.

8. Dispatch

   - 함수의 동작을 정의하는 타입.

9. MouseEvent

   - click, hover 등과 같은 이벤트를 처리하는 데에 사용

   ChangeEvent

   - 주로 폼 요소의 변화에 대한 이벤트를 처리하는 데에 사용 (ex: `input`, `select`, `textarea`)

   FormEvent

   - 양식이 제출될 때 발생하는 이벤트

   HTML<>Element (HTMLDivElement, ...etc)

   - 특정 HTML요소의 유형을 나타냄
   - DOM의 요소 유형을 지정하는 데에 사용됨

---

### 📝 task5

#### task 5 - 1

토론 결과, 타입이 추론이 충분히 가능할 경우(매개변수에 타입을 줬는데, 반환값의 타입이 매개변수와 타입이 똑같을 때), 타입을 굳이 안
줘도 된다는 잠정적이 결론이 나왔습니다. WIL에서 이 주제로 회의를 했는데 코드의 컨벤션과 협업을 위해 유추할 수 있는 경우에도 타입을 주어야 한다는
의견이 있었습니다. 비록 저희와 의견은 달랐지만, 반대 경우의 근거를 들을 수 있어서 좋았습니다.

#### task 5 - 2

vite, CRA로 모두 진행하였습니다.

#### task 5 - 3

type alias와 interface의 차이점을 먼저 정리하고, 해당 차이점에 대한 예제를 하나씩 만들어서 정리하였습니다. 그 후 다음과 같은 결론이 나왔습니다.

<b> 타입과 인터페이스의 기능은 크게 다르지 않다. 그러므로 팀에서 어떤 컨벤션을 선택하는지가 중요하며 그것을 따르는 것이 중요하다.
보통은 인터페이스보다 타입 앨리어스를 가독성과 다양한 문법 측면에서 더 좋아 선호하는 편이다. </b>

#### task 5 - 4

- Todo component

  - todo/index.tsx와 one-todo.tsx에서 사용하는 TodoData의 타입이 동일하여 type폴더를 만들고 Todo type을 모듈화 했습니다.

- Button component
  - variant, size type : 유니온 타입으로 지정하여 Button 컴포넌트가 받은 props 값에 따라 css가 바뀔 수 있게 했습니다.
  - ...rest type : variant와 size속성 말고도 button 태그 고유의 속성들을 이용하기 위해 ButtonHTMLAttributes<HTMLButtonElement>타입을 지정했습니다.

### 회고

#### 🎾 Rin

타입스크립트로 이미 프로젝트를 몇번 해봐서 익숙하다고 생각했지만, 그건 저의 착각이라는 것을 깨달았습니다..ㅎㅎ이번에 거의 모든 타입을 정리하면서
제가 얼마나 타입을 제한적으로 쓰고 있었는지, 대충 쓰고 any를 남발했는지 알게 되었고 반성했습니다..!
이렇게 정석으로 공부하는 것은 시간이 오래 걸리지만 그만큼 효과가 있는 것 같습니다. 다른 개념도 이렇게 공부해야 겠다고 생각했습니다. <br/>
특히 JS Docs를 TS가 대체할 수 있다는 것은 이번 패쓰가 아니었다면, 생각치도 못했을 것 같습니다. (한 문제마다 빅픽쳐를 그리는
피넛님께 박수..)
같이 진행한 분위기 메이커 키미, 이해력도 드립력도 높은 다니엘 덕분에 꼼꼼하면서도 재밌게 소통하면서 진행해서 좋았습니다😁

#### ⚽️ Daniel

막연하게 데이터 타입 + 자바스크립트라고 생각했던 타입 스크립트를 확실하게 알게 된 시간이어서 좋았습니다! <br/>
type-safety 환경을 만들어 에러 발생 가능성을 줄이고, 자동완성으로 인한 개발의 편의성 등 타입 스크립트의 매력을 충분히 느낀 거 같습니다. <br/>
더 공부하여 상황에 맞는 최적의 타입을 지정할 수 있도록 성장하고 싶숨당!<br/>
페어 분들과 재밌게 소통하면서 패스를 진행하니, 더욱 이해가 잘 된 거 같아 좋았습니다!

#### 🏀 Kimi
