### 어떤 순간에 타입을 줘야 할까?

##### 타입을 주어야하는 경우와 주지 않아도 되는 경우를 구분하기

⬇️ javascript

```javascript
let seongyong = {
  age: 20,
  height: 190,
};

function log(obj) {
  console.log(obj.height);
  return obj;
}

const a = log(seongyong);
console.log(a.age);
```

⬇️ typescript

```typescript
interface Person = {
  age: number,
  height: number,
};

let seongyong:Person = {
    age: 20,
    height: 190
}

```

<br />

1. 매개변수의 타입과 리턴 값의 타입이 동일할 경우 👉 TS 선택

```typescript
function log(obj: Person) {
  console.log(obj.height);
  return obj;
}
```

<br />

2. 리턴 값의 타입을 매개변수의 타입만으로는 추론이 안 되는 경우 👉 TS 필수 <br />
   ex. 타입 합성

```typescript

interface Movvi = {
    nickname: string,
    isDirector: boolean,
}


function log(obj: Person):Person & Movvi{
    return {...obj, nickname : 'Peanut', isDirector: true}
}

```

<br />

3. 함수 오버로딩 👉 TS 필수 <br />
   함수 오버로딩이란 매개변수가 다르며 이름이 동일한 함수를 말함

3-1. 매개변수의 개수는 동일하지만, 타입이 다른 경우

```typescript
function combine(a: string, b: string): string;
function combine(c: number, d: number): number;

// string + number 연산이 안 돼서 에러 발생
function combine(a: string | number, b: string | number): string | number {
  return a + b;
}

// 근데 any는 쓰면 안 좋은 거 아닌가요..?
function combine(a: any, b: any): any {
  return a + b;
}

// 🫢 type guard를 사용하면 any를 쓰지 않을 수 있음
function combine(a: string | number, b: string | number): string | number {
  if (typeof a === "number" && typeof b === "number") return a + b;
  return Number(a) + Number(b);
}
```

3-2. 매개변수의 개수는 다르지만, 타입은 동일한 경우

```typescript
function add(a: number): number;
function add(a: number, b: number): number;
function add(a: number, b?: number, c?: number): number;

function add(a: number, b?: number, c?: number): number {
  return a + (b ?? 0) + (c ?? 0);
}

console.log(add(1, 2, 3));
```

3-3. 매개변수의 개수와 타입이 다른 경우

```typescript
function userInfo(name: string): void;
function userInfo(age: number, gender: string): void;

function userInfo(name?: string, age?: number, gender?: string): void {
  // ... code
}
```
